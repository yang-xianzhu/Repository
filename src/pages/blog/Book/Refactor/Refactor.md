---
title: 重构
description: books
layout: ../../../../layouts/MainLayout.astro
---

## 重构

> 如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。

**好代码的检验标准就是人们是否能够轻而易举地修改它。**

## 重构的原则

### 何谓重构

**重构**（名词）：对软件内部结构的一种调整，目的是在不改变软件可观擦行为的前提下，提高其可理解性，降低其修改成本。

**重构**（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

可观察行为，整体而言，经过重构之后的代码所做的事应该与重构之前大致一致。这个说法并非完全严格，因为：**重构之后的代码不一定与重构前行为完全一致。比如说，提炼函数会改变函数调用栈，因此程序的性能就会有所改变；改变函数声明和搬移函数等重构经常会改变模块的接口**。

### 两项帽子

`两项帽子`的比喻：**添加新功能**和**重构**。

添加新功能时，我们不应该修改既有代码，只管添加新功能。通过添加测试并让测试正常进行，我们可以衡量自己的工作进度。重构时我们就不能再添加功能，只管调整代码的结构。此时我们不应该添加任何测试（除非发现有先前遗漏的东西），只在绝对必要（用以处理接口变化）时才修改测试。

### 为何重构

#### 重构改进软件的设计

如果没有重构，程序的内部设计（或者叫架构）会逐渐腐败变质。当人们只为短期目的而修改代码时，他们经常没有完全理解架构的整体设计，于是代码逐渐失去了自己的结构。程序员越来越难通过阅读源码来理解原来的设计。代码结构的流失有累积效应。越难看出代码所代表的设计意图，就越难保护其设计，于是设计就腐败得越快。经常性重构有助于代码维持自己该有的形态。

完成同样一件事，**设计欠佳的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事，因此改进设计的一个重要的方向就是消除重复代码**。代码量减少并不会将使系统运行得更快，因为这对程序的资源占用几乎没有任何明显影响。然而代码量减少将使未来可能的程序修改动作容易得多。代码越多，做正确的修改就会越困难，因为有更多代码需要理解。比如我们在这里做了一点儿修改，系统却不如如期那样工作，因为我没有修改另一次--那里的代码做着几乎完全一样的事情，只是所处环境略有不同，消除重复代码，我就可以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本。

#### 重构使软件更容易理解

所谓程序设计，很大程度上就是与计算机对话，我编写代码告诉计算机做什么事，而它的响应就是按照我的指示精确行动。一言以蔽之，我所做的就是填补`我想要它做什么`和`我告诉它怎么做`之间的缝隙。编程的核心就在于`准确说出我想要的`。然而别忘了，除了计算机之外，源码还有其他读者：几个月之后可能会有另外一位程序员尝试读懂我的代码并对我的代码做一些修改。我们很容易忘记这位读者，但他才是最重要的。计算机是否多花几个时钟周期来编译，又有什么关系呢？如果一个程序员多花费一周时间来修改其段代码，这才要命。问题在于，当我们努力让程序运转的时候，我们不会想到未来出现的那个开发者。是的，我们应该改变一下开放节奏，让代码变得更易于理解。重构可以帮我让代码更易读。开始进行重构前，代码可以正常运行，但结构不够理想。在重构上花一点点时间，就可以让代码更好地表达自己的意图-更清晰地说出我想要做的。

#### 重构帮助找到bug

#### 重构提高编程速度

### 何时重构

> 第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，就应该重构。事不过三，三则重构。

#### 预备性重构：让添加新功能更容易

重构的最佳时机就在添加新功能之前。

#### 帮助理解的重构：使代码更易懂

一旦我们需要思考这段代码到底在做什么，就可以考虑能不能重构这段代码，令其一目了然。

重构带来的帮助不仅发生在将来—常常是立竿见影。我们会在一些小细节上使用重构来帮助理解代码，给一两个变量改名，让它们更清楚地表达意图，以方便理解，或是将一个长函数拆成几个小函数。

#### 捡垃圾式重构

重构的妙处就在于，每个小步骤都不会破坏代码—所以，有时一块垃圾在好几个月之后才终于清理干净，但即使每次清理并不完整，代码也不会被破坏。

#### 有计划的重构和见机行事的重构

预备性重构、帮助理解的重构、捡垃圾式重构—都是见机行事的：我们并不专门安排一段时间来重构，而是在添加功能或修复bug的同时顺便重构。

> 肮脏的代码必须重构，但漂亮的代码也需要很多重构。

长久以来，人们认为编写软件是一个累加的过程：要添加新功能，我们就应该增加新代码。但优秀的程序员知道，添加新功能最快的方法往往是先修改现有的代码，使新功能容易被加入。所以，软件永远不应该被视为**完成*。每当需要新功能时，软件就应该做出相应的改变。越是在已有代码中，这样的改变就显得越重要。

### 长期重构

大多数重构可以在几分钟—最多几小时一一完成。

如果想替换掉一个正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口。一旦调用方已经完全改为使用这层抽象，替换下面的库就会容易得很多。

#### 复审代码时重构



