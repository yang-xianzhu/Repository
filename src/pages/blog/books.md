---
title: 书籍
description: books
layout: ../../layouts/MainLayout.astro
---

## JavaScript高级程序设计-第四版

#### 函数

###### 尾调用优化

- 简介：ECMAScript规范新增了一项内存管理优化机制，让javascript引擎在满足条件时可以重用栈帧。
- 需要条件：
  - 代码在严格模式下执行；
  - 外部函数的返回值是对尾调用函数的调用；
  - 尾调用函数返回后不需要执行额外的逻辑；
  - 尾调用函数不是引用外部函数作用域中自由变量的闭包；

> 之所以要求严格模式，主要因为在非严格模式下函数调用中允许使用f.arguments和f.caller,而它们都会引用外部函数的栈帧。显然，这意味着不能应用优化了。因此尾调用优化要求必须在严格模式下有效，以防止引用这些属性。



###### 闭包

1. 简介：匿名函数经常被误认为是闭包（closure）。`闭包`指的是那些引用了另外一个函数作用域中变量的函数，通常是在嵌套函数中实现。

> 注意：使用不当容易产生内存泄漏。产生原因：错误引用该变量，导致引用一直存在，垃圾回收机制一直没回收。



###### 立即调用的函数表达式

​		立即调用的匿名函数又被称作`立即调用的函数表达式` （IIFE，Immediately Invoked Function Expressopn）。它类似函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟着第一组括号后面的第二组括号就会立即调用前面的函数表达式。

```js
(function (){
  // 块级作用域
})()
```

​		在es6及以前，为了防止变量定义外泄，IIFE是个非常有效的方式。这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕，其作用域链就可以被销毁。

​		在es6之后，IIFE就没有那么必要了，因为块级作用域中的变量无须IIFE就可以实现同样的隔离。

```js
// 内嵌块级作用域
{
  let i;
  for(i=0;i < count; i++){
    console.log(i)
  }
}
console.log(i)  // 抛出错误！

// 循环的块级作用域
for(let i = 0;i < count; i++){
  console.log(i)
}
console.log(i)  // 抛出错误！

// 说明IIFE用途的一个实际的例子，就是可以用它锁定参数值。比如：
const divs = document.querySelectorAll('div')

// 达不到目的
for(var i = 0; i< divs.length;i++){
  divs[i].addEventListener('click',function(){
    console.log(i)
  })
}
```

这里使用 `var` 关键字声明了循环迭代变量i，但这个变量并不会被限制for循环的块级作用域内。因此，渲染到页面上之后，点击每个div都会弹出元素总数。这是因为在执行淡季处理程序时，迭代变量的值已经上循环结束时的最终值了，即元素的个数。而且，这个变量存在于循环体外部，随时可以被访问。这里也可以用到 `IIFE` 解决。



#### DOM

细节：

- DOM操作在javascript代码中代价是比较高的，NodeList对象尤其需要注意。NodeList对象是`"实时更新"`的，这意味着每次访问它一次都要执行一次查询。考虑到这些问题，实践中要尽量减少DOM操作数量。
- MutaionObserver是为代替性能不好的MutaionEvent而问世的。使用它可以有效精准监控DOM变化，而且api相对简单。



#### 动画与Canvas图形

- 虽然使用setInterval()的定时动画比使用多个setTimeout()实现循环效率更高，但也不是没有问题。无论是setInterval()还是setTimeout()都是`不能保证时间精度`的。作为第二个参数的延时只能保证何时会把代码添加到浏览器的`任务队列`，不能保证添加到任务队列就会立即执行。如果队列前面还有其他任务，那么就要等那些任务执行完毕再执行。简单来说，这里毫秒延时并不是何时这些代码就会执行，而只是说到了这个时间就会把回调添加到任务队列。如果添加到队列后，主线程还在被其他任务占用，比如正在处理用户操作，那么回调就不会马上执行。

> 解决方法：使用requestAnimationFrame方法


#### 网络请求与远程资源

###### 跨源资源共享

通过 `XHR` 进行ajax通信的一个主要限制是 `跨源安全策略`。默认情况下，XHR只能访问与发起请求页面在同一个域内的资源。

- ###### 预检请求

  - 简介：COES通过一种叫 `预检请求` 的服务器验证机制，允许使用自定义头部、除了GET和POST之外的方法，以及不同请求体内容类型。在要发送涉及上述某种高级选项的请求时，会先向服务器发送一个"预检"请求。这个请求使用options方法发送并包含一下头部。
    - Origin：与简单请求相同。
    - Access-Control-Request-Method：请求希望使用的方法。
    - Access-Control-Request-Headers：（可选）要使用的逗号分隔的自定义头部列表。

###### 替代性跨源技术

- ###### 图片探测

  - 简介：图片探测是利用 `<img>` 标签实现跨域通信的最早的一种技术。任何页面都可以跨域加载图片而不必担心限制，因此这也是在线广告追踪的主要方式。可以动态创建图片，任何通过它们的 `onload` 和 `onerror` 事件处理程序得知何时收到响应。
  - 图片探测是与服务器之间 `简单` 、`跨域` 、`单向` 的通信。

###### Fetch API

- 简介：Fetch API能够执行 XMLHttpRequest 对象的所有任务，但更容易使用，接口也更现代化，能够在Web工作线程等现代Web工具中使用。XMLHttpRequest可以选择异步，而Fetch API则必须是异步。Fetch API 本身是使用javascript请求资源等优秀工具，同时这个API也能够应用在服务线程（service worker） 中，提供拦截、重定向和修改通过fetch（）生成的请求接口。

###### Beacon API

- 简介：为了把尽量多的页面信息传到服务器，很多分析工具需要在页面生命周期中尽量晚的时候向服务器发送遥测或分析数据。因此，理想情况下是通过浏览器的 `unload` 事件发送网络请求。

> 在unload事件处理程序中创建的任何的异步请求都会被浏览器取消。

###### Web Socket

- 简介：

  ​Web Socket（套接字）的目标是通过一个长时连接实现与服务器 `全双工` 、`双向` 的通信。javacript中创建Web Socket时，一个HTTP请求会发送到服务器以初始化连接。

  ​因为Web Socket使用了自定义协议，所以URL方案（scheme）稍有变化：不能再使用 `http://` 或 `https://`，而要使用 `ws://` 或 `wss://`。前者是不安全的连接，后者是安全连接。 

  ​使用自定义协议而非HTTP协议的好处是，客户端与服务端之间可以发送非常少的数据，不会对HTTP造成任何负担。使用更少的数据包让 Web Socket 非常适合**带宽**和**延迟**问题比较明显的移动应用。使用自定义协议的缺点是，定义协议的时间比定义Java script API要长。

- API

​		要创建一个Web Socket，就要实例化一个 `WebSocket`  对象并传入提供连接的URL：

```js
const socket = new WebSocket('绝对路径的url地址');
```

​		注意，必须给WebSocket构造函数传入一个绝对URL。同源策略不适用于Web Socket，因此可以打开到任意站点的连接。至于是否与来自特定源的页面通信，则完全取决于服务器。（在**握手**阶段就可以确定请求来自哪里）

​		WebSocket.OPENING(0)：连接正在建立。

​		WebSocket.OPEN(1)：连接已经建立。

​		WebSocket.CLOSING(2)：连接正在关闭。

​		WebSocket.CLOSE(3)：连接已关闭。

> 任何时候都可以调用close()方法关闭WebSocket的连接。
>
> socket.close()

- 发送和接收数据

​		服务器向客户端发送消息时，WebSocket对象上会触发**message**事件。

```js
socket.onmessage = function (event) {
  const data = event.data
}
```

- 其他事件

> WebSocket对象不支持DOM Level2事件侦听器，因此需要使用DOM Level0风格的事件处理程序来侦听这些事件。

```js
const socket = new WebSocket('url')

socket.onopen = function (){
  ...
}
 
socket.onerror = function (){
  ...
}
  
socket.onclose = function (){
  ...
}
```

在这些事件中只有**close**事件的event对象有额外信息。这个对象有三个属性：

- wasClean：是一个布尔值，表示连接是否干净地关闭；
- code：是一个来自服务器的数值状态码；
- reason：是一个字符串，包含服务器发来的信息。

###### 安全

​		在未授权系统可以访问某个资源时，可以将其视为**跨站点请求伪造**（CORF）攻击。未授权系统会按照处理请求的服务器的要求伪装自己。Ajax应用程序，无论大小，都会受到CSRF攻击的影响，包括无害的漏洞验证攻击和恶意的数据盗窃或数据破坏攻击。

​		关于安全防护Ajax相关URL的一般理论认为，需要验证请求发送者拥有对资源的访问权限，可以通过一下方式实现：

- 要求通过SSL访问能够被Ajax访问的资源。
- 要求每个请求都发送一个按约定算法计算好的令牌（token）。

​	注意：以下手段对防护CSRF攻击是无效的。

- 要求POST而非GET请求（很容易修改请求方式）
- 使用来源URL验证来源（来源URL很容易被修改）
- 基于cookie验证（同样很容易被伪造）

​	

###### 小结

- XHR的一个主要限制是同源策略，即通信只能在**相同域名**、**相同端口**、**相同协议**的前提下完成。
- 图片探测和JSONP是另外两种跨域通信技术，但没有CORS那么可靠。
- Fetch API是作为对XHR对象的一种端到端的替代方案而提出的。这个API提供了优秀基于期约（promise）的结构、更直观的接口，以及对 Stream API的最好支持。

#### 客户端存储

1. ###### cookie：

​		HTTP cookie 通常也叫做cookie。最初用于在客户端存储会话信息。这个规范要求服务器在响应HTTP请求时，通过发送Set-CookieHTTP头部包含会话信息。

​		浏览器会存储这些会话信息，并在之后的每次请求都会通过HTTP头部cookie再将它们吗发回服务器。

- 限制

​		cookie是与特定域绑定的。设置cookie后，它会与请求一起发送到创建它的域。这个限制能保证cookie中存储的信息只对被认可的接收者开放，不被其他域访问。

​		因为cookie存储在客户端机器上，所以为了保证它不会被恶意使用，浏览器会施加限制。，同时cookie也不会占用太多磁盘空间。

通常，只要遵守以下大致的限制，就不会在任何浏览器碰到问题。

- 不超过**300**个cookie；
- 每个cookie 不超过**4096**字节；
- 每个域不超过**20**个cookie；
- 每个域不超过**81920**字节；

每个域能设置的cookie总数也是受限的，但不同浏览器的限制不同。

- 最新版IE和Edge限制每个域不超过**50**个cookie；
- 最新版Firefox限制每个域不超过**150**个cookie；
- 最新版Opera限制每个域不超过**180**个cookie；
- Safari和Chrome对每个域的cookie数没有硬性控制；

> 注意：
>
> 这个大小限制适用于一个域的所有cookie，而不是单个cookie。
>
> 如果创建的cookie超过最大限制，则该cookie会被静默删除。

- 使用cookie的注意事项

​		因为所有cookie都会作为请求头部由浏览器发送给服务器，所以在cookie中保存大量信息可能会影响特定域浏览器请求的性能。保存的cookie越大，请求完成的时间就会越长。既使浏览器对cookie大小有限制，最好还是尽可能值通过cookie保存必要信息，以避免性能问题。

2. Web Storage

​		Web Storage 最早是网页超文本应用技术工作组在 Web Applications1.0规范中提出的。Web Storage的目的是解决通过客户端存储不需要频繁发送回服务器的数据时使用cookie的问题。

​		Web Storage规范有两个目标：

- 提供在cookie之外的存储会话数据的途径。
- 提供跨会话持久化存储大量数据的机制。

​		Web Storage 的localStorage 和 sessionStorage。localStorage是永久存储机制，sessionStorage 是跨会话的存储机制。

> 注意：Web Storage 第一版曾使用过 globalStorage，不过目前globalStorage已废弃了。

​		所有现代浏览器在实现存储写入时都使用了**同步阻塞**方式，因此数据会被立即提交到存储中。具体API到实现可能不会立即把数据写入磁盘（而是使用某种不同物理存储），但这个区别在JavaScript层面是不可见的。通过Web Storage写入的任何数据都可以立即被读取。

​		老版本的IE以异步方式实现的数据写入，因此给数据赋值的时间和数据写入磁盘的时间可能存在延迟。

- 存储事件

每当Storage对象发生变化时，都会在文档上触发**storage**事件。使用属性或者setItem（）设置值，使用delete或removeItem（）删除值，以及每次调用clear（）时都会触发这个事件。

1. domain：存储变化对应的域。
2. key：被设置或删除的键。
3. newValue：键被设置的新值，若键被删除则为null。
4. oldValue：键变化之前的值。

```js
window.addEventListener('storage', (event)=>{
  // ...
})
```

对于sessionStorage 和 localStorage 上的任何更改都会触发 storage 事件，但storage事件不会区分这两者。

- 限制

不同浏览器给 localStorage 和 sessionStorage 设置了不同的空间限制，但大多数会限制每个源5MB。

3. IndexedDB

Indexed Database API简称**IndexedDB**，是浏览器中存储结构化数据的一个方案。

IndexedDB的设计几乎完全是**异步**的。

- 数据库

与传统数据库最大的区别在于，IndexedDB使用对象存储而不是表格保存数据。

4. 限制

IndexedDB数据库是与页面源（协议、域名、端口号）绑定的，因此信息不能跨域共享。

#### 模块

1. 理解模块模式

将代码拆分成独立的快，然后再把这些块连接起来可以通过模块模式来实现。

- 模块标识符

​	模块标识符书所有模块系统通用的概念。模块系统本质上是键/值实体，其中每个模块都有个可用用用的标识符。

- 模块依赖

​	模块依赖的核心是管理依赖。指定依赖的模块与周围的环境会达成一种契约。本地模块向模块系统声明一种外部模块（依赖），这些外部模块对于当前模块正常运行时必需的。模块系统检视这些依赖，进而保证这些外部模块能够被加载并在本地模块运行时初始化所有依赖。

- 模块加载

​	加载模块的概念派生自依赖契约。当一个外部被指定为依赖时，本地模块期望在执行它时，依赖已准备好并初始化。

​	在浏览器中，加载模块涉及几个步骤。加载模块涉及执行其中的代码，但必须是在所有依赖都加载并执行之后。如果浏览器没有收到依赖模块的代码，则必须发送请求并等待网络返回，收到模块代码后，浏览器必须确定刚收到的模块是否也有依赖。然后递归地评估并加载所有依赖，直到所有依赖模块都加载完成，只有整个依赖图都加载完成，才可以执行入口模块。

- 入口

​	互相依赖的模块必须指定一个模块作为入口，这也是代码执行的**起点**。

![image-20221011230940545](/红宝书-模块-01.png)

​	图中箭头表示依赖方向：模块A依赖模块B和模块C，模块B依赖模块D和模块E，模块C依赖模块E。因为模块必须在依赖加载完成才能被加载，所以这个应用程序的入口模块A必须在应用程序的其他部分加载后才能执行。

​	模块加载是**"阻塞"**的。这意味着前置操作前必须完成才能后置操作。

- 动态依赖

​	动态依赖可以支持更复杂的依赖关系，但代价是增加了对模块进行静态分析的难度。

- 静态分析

​	更复杂的模块行为，例如动态依赖，会导致静态分析更困难。

2. 使用ES6之前的模块加载器
   1. CommonJS
      - CommonJS规范概述了同步声明依赖的模块定义。
      - CommonJS模块语法不能直接在浏览器中直接运行。
      - 无论一个模块在**require()**引用多少次，模块永远都是**单例**的。
      - 模块**第一次加载后会被缓存**，后续加载会取得缓存的模块。

- 模块加载

​	完全支持ECMAScript6模块的浏览器可以从顶级模块加载器加载整个依赖图，且是**异步**的。

- 模块行为

​	ECMAScript6模块借用了CommonJS 和 AMD 的很多优秀特性。

 	1.	模块代码只在加载后执行。
 	2.	模块只能加载一次。
 	3.	模块是单例的。
 	4.	模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。
 	5.	模块可以请求加载其他模块。
 	6.	支持循环依赖。

ES6模块系统也增加了一些新行为。

1. ES6模块默认在严格模式下执行。
2. ES6模块不共享全局命名空间。
3. 模块顶级this的值是undefined（常规脚本中是window）。
4. 模块中的var声明不会添加到window对象。
5. ES6模块是异步加载和执行的。

- 模块导入

​	与**export**类似，import必须出现在模块的顶级。

​	如果在浏览器中通过标识符原生加载模块，则文件必须带有 **js**扩展名，不然可能无法正确解析。

​	不是必须通过到处的成员才能导入模块。如果不需要模块的特定导入，但仍然想加载和执行模块以利用其**副作用**，可以通过路径加载它。

```js
import './test.js'  // 执行test文件的副作用
```

​	导入对模块而言是**只读的**。实际上相当于const声明对变量。在使用*执行批量导入时，赋值给别名对命名到处就好像使用Object.freeze()冻结过一样。直接修改导出的值是不可能的，但可以修改导出对象的属性。

```js
import { default as foo } from './foo.js'
// 等效于如下
import foo from './foo.js'
```

- 向后兼容

	浏览器在调用`<script>`标签上无法识别等type属性时会拒绝执行其内容。对于不支持模块的浏览器，这意味着`<script type="module">`不会被执行。


#### 最佳实践

1. ###### 可维护性

   - 什么是可维护性的代码
     - **容易理解**：无须求助原始开发者，任何人一看代码就知道它是干什么的，以及它怎么实现的。
     - **符合常识**：代码中的一切都显得顺利成章，无论操作有多么复杂。
     - **容易适配**：即使数据发生变化也不用完全重写。
     - **容易扩展**：代码架构经过认真设计，支持未来扩展核心功能。
     - **容易调试**：出问题时，代码可以给出明确的信息，通过它能直接定位问题。
   - 编码规范
     - 可读性
       - 函数和方法：每个函数和方法都应该有注释来描述其用途。
       - 大型代码块：多行代码但用于完成**单一任务**的，应该在前面给出注释，把要完成的任务写清楚。
       - 复杂的算法：如果使用了独特的方法解决问题，要通过注释解释清楚。这样不仅可以帮助别人查看代码，也可以帮助自己今后查看代码。
       - 使用黑科技：由于浏览器之间的差异，Java script代码中通常包含一些黑科技，不要假设其他人一看就能明白某个黑科技是为了解决某个浏览器的什么问题。如果某个浏览器不能使用正常方式达到目的，那要在注释里把黑科技的用于写出来。这样**避免别人误认为黑科技没有用于把它“修复”掉**，结果你已解决掉问题又会出现。
     - 松散耦合
   - 编码惯例
     - 尊重对象的所有权
       - 不要给实例或原型添加属性或方法
       - 不要重定义已有的方法

   > 最好的方法是永远不要修改不属于自己的对象，只有你自己创建的对象，包含自定义类型和对象字面量。

   - 创建包含需要功能的新对象，通过它与别人的对象交互。

   - 创建新自定义类型继承本来想要修改的类型，可以给自定义类型添加新功能。

     - 不声明全局变量

     与尊重对象所有权密切相关的是尽可能的不声明全局变量和函数。

   - 不要比较**null**

     > 检查值的类型就要真的检查类型，而不是检查它不能是什么。

     - 如果值应该是**引用类型**，则可以使用**instanceof**操作符检查其构造函数。
     - 如果值应该是**简单类型**，则可以使用**typeof**操作符检查其类型。
     - 如果希望值是有特定方法名的对象，则使用**typeof操作符确保对象上存在给定名字的方法。

     > 代码中比较null的地方越少，就越容易明确类型检查的目的，从而消除不必要的错误。

   - 使用常量

   依赖常量的目标是从应用程序逻辑中分离数据，以便修改数据时不会引发错误。

   1. **重复出现的值**：任何使用超过一次的值都应该提取到常量中，这样可以消除一个值改了而另外一个值没改造成的错误。这里也包含**CSS的类名**、**清除本地存储的key**等。
   2. **用户界面字符串**：任何会显示给用户的字符串的一个提取出来，以方便**实现国际化**。
   3. **URL**：Web应用程序中资源的地址经常会发生变化，因此建议把所有的URL集中放到一个地方管理。
   4. **任何可能变化的值**：任何时候，只要在代码中使用字面量，就问问自己这个值将来是否会变。如果答案是“是”，那么就应该把它提取到常量中。

   > 使用常量是企业级Java script开发到重要方式，因为它可以让代码更容易维护，同时可以让代码免受数据变化的影响。

2. ###### 性能

JavaScript一开始就是一门解释型语言，因此执行速度比编译语言要慢一些。

> 任何可以缩短遍历作用域链时间拆措施都能提升代码性能。

- 作用域意识

  - 避免全局查找

  改进代码性能非常重要的一件事，可能就是要提防**全局查询**。全局变量和函数相比于局部值始终是最费时间的，因为想要经历作用域链查找。

  ```js
  function updateUI(){
    const imgs = document.getElementsByTagName('img')
    const _len = imgs.length
    for(let i=0;i<_len;++i){
      // ...
    }
  }
  ```

  > 通过在局部作用域中保存docuemnt对象，能够明显提升这个函数的性能，因为只需要作用域查找一个指向document对象的局部变量。

  > 只要函数中引用超过两次的全局对象，就应该把这个对象保存为一个局部变量。

  - 不使用with语句

  实际编码时很少需要使用**with**语句的情况，因为它的主要用途是节省一点代码。大多数情况下，使用**局部变量**可以实现同样的效果，无须增加新作用域。

- 选择正确的方法

​	影响性能的因素通常涉及到算法和解决问题的方法。

1. 避免不必要的属性查找

​	最简单同时也最快的算法可以表示为**常量值**或**O(1)**。

|  表示法  |  名称  |                             说明                             |
| :------: | :----: | :----------------------------------------------------------: |
|   O(1)   |  常量  |  无论多少值。执行时间都不会变。表示简单值和保存在变量中的值  |
| O(logn)  |  对数  | 执行时间随着值的增加而增加。但算法完成不需要读取每个值。例子：二分查找 |
|   O(n)   |  线性  |     执行时间与值的数量直接相关。例子：迭代数组的所有元素     |
| O(n平方) | 二次方 | 执行时间随着值的增加而增加，而且每个值至少读取n次。例子：插入排序 |

常量值O(1)，指字面量和保存在变量中的值，表示读取常量值所需的时间不会因值的多少而变化。读取常量值是效率极高的操作。因此非常快。

> 在Java script中访问数组元素也是O(1)操作，与简单的变量查找一样。

使用变量和数组相比访问对象属性效率更高，**访问对象属性**的算法复杂度是**O(n)**。访问对象的每个属性都比访问变量和数组花费时间要长，因为查找属性名要**查找原型链**。

> 通过数代码中的点号数量，就可以知道有几次属性查找了。

只要使用某个object属性超过一次，就应该将其保存在局部变量中。第一次仍然要使用算法复杂度为O(n)去查找，但后续每次访问属性就都是O(1),这样做就是质的提升了。

2. 优化循环

   1. **简化终止条件**：因为每次循环都会计算终止条件，所以它应该尽可能地快。这意味着要比慢属性查找或其他的O(n)操作。
   2. **简化循环体**：循环体是最花时间的部分，因此要尽可能优化。要确保其中不包含可以轻松转移到循环外的密集计算。
   3. **使用后测试循环**：最常用的循环就是`for`、`while`循环。这两种循环都属于**先测试循环**，`do-while`就是后测试循环，避免对终止条件初始评估，因此会更快。

   ```js
   注意：在旧版浏览器中，从循环体迭代器的最大值开始递减至0点效率更高。之所以这样更快，是因为javascript引擎用于检查循环分支条件的指令数更少。在现代浏览器中，正序还是倒序不会有感知的性能差异。
   ```

   3. 展开循环

   如果循环次数是有限的，那么通常抛弃循环而直接多次调用函数会更快。

   > 如果不能提前预知循环的次数，那么或许可以使用一种叫做**达夫设备**的技术。
   >
   > 达夫设备的基本思路是以8的倍数作为迭代次数从而将循环展开为一系列语句。

   4. 避免重复解释

   很少有情况绝对要使用**eval()**，因此应该尽可能不使用它。

   5. 其他性能优化注意事项
      - **原生方法很快**：应该尽可能的使用原生方法，而不是使用Java script写的方法。原生方法是使用**C**或**C++**等编译语言写的，因此比javascript写的方法要快很多。
      - **switch语句很快**：如果代码中有复杂的`if-else`，将其转换成`switch`语句可以变得更快。然后，通过重新组织分支，把最有可能的放到最前面，不太可能的放到后面，可以进一步提升性能。
      - 位操作很快：在执行数学运算操作时，位操作一定比任何布尔值或数值计算更快。

- 语句最少化

javascript代码中语句的数量影响操作执行的速度。一条可以执行多个操作的语句，比多条语句每个语句执行一个操作更快。那么优化的目标就是寻找可以合并的语句，以减少整个脚本的执行时间。

​	1.	多个变量声明

```js
const num =0;
const isshow = true;
const str = 'yxz'
// 可以转换为一下
const num =0,
      isShow = true,
      str = 'yxz'
```

  		2.	插入迭代性值
  		3.	使用数组和对象的字面量

尽可能的使用数组或对象字面量，减少不必要的语句。

- 优化DOM交互

 1. 实时更新最小化

    访问DOM时，只要访问的部分是显示页面的一部分，就是在执行**实时更新**操作。

 2. 使用innterHTML

​		原生DOM方法速度更快，因为该方法是在执行编译代码而非解释代码。

> 注意：使用innterHTML可以提升性能，但也会暴露巨大的XSS攻击面。无论何时使用它填充不受控的数据，都有可能被攻击者注入可执行代码。

 	3.	使用**事件委托**

​		事件委托利用事件冒泡。任何冒泡的事件都可以不在事件目标上，而在目标的任何元素上处理。

只要可能，就应该在**文档级**添加事件处理程序，因为在文档级可以处理整个页面的事件。事件委托还有一个好处就是，对于ul下后新增的li，利用事件委托也可以绑定事件。

4. 注意HTMLCollection

​		编写javascript代码时，关键是要记住，只要返回的**HTMLCollection**对象，就应该尽可能不访问它。

- 调用**getElementsByTagName()**
- 读取元素的**chidNodes**属性
- 读取元素的**attributes**属性
- 调用特殊的集合，如**document.form**、**document.images**等


## 你不知道的JavaScript系列-上卷

### 作用域是什么

几乎所有编程语言最基本的功能之一，就是能够存储变量当中的值，并且能在之后对这个值进行访问或修改。事实上，正是这种存储和访问变量的值的能力将**状态**带给了程序。

#### 1.1 编译原理

尽管通常将javascript归类为"动态" 或 “解释执行” 语言，但事实上它是一门**编译**语言。但与传统的编译语言不用。它不是提前编译的，编译结果也不能在分布式系统进行移植。

- ##### 分词/词法分析

这个过程会将由字符串分解成（对编译语言来说）有意义的代码块，这些代码块被称为**词法单元**。例如，考虑程序 `var a = 2;`。这段程序通常会被分解成下面这些词法单元： `var、a、2、；`。

> 注意：空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。

> 分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过**有状态**还是**无状态**的方式进行的。如果词法单元生成器在判断a是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。

- ##### 解析/语法分析

这个过程是将词法单元流（数组）转换为一个由元素逐级嵌所组成的代表了程序语法结构的书。这个树叫做**“抽象语法树”**（AST）。

- ##### 代码生成

将AST转换为可执行代码的过程被称为代码生成。

抛开具体细节，简单来说就是有某种方法可以将 var a = 2；这个AST转化为一组机器指令，用来创建一个叫做a的变量（包含分配内存），并将这个值存储在a中。

> JavaScript引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同，**JavaScript的编译过程不是发生在构建之前的**。
>
> 对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。
>
> 任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）。

#### 1.2 理解作用域

- **引擎**：从头到尾负责整个Javascript程序的编译及执行过程。
- **编译器**：引擎的好朋友之一，负责语法分析及代码生成等脏活累活。
- **作用域**：引擎的另一个好朋友，主要负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

下面将**var a = 2；**，进行分解

编译器首先会将这段程序分解成**词法单元**，然后将词法单元解析成一个树结构。

1. 遇到var a，编译器会询问作用域是否已经在一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新变量，并命名为 a。
2. 接下来编译器会为引擎生成运行时所需的代码。这些代码被用来处理 a = 2这个赋值操作。引擎运行时会首先询问当前作用域，在当前作用域集合中是否存在一个**a**变量。如果是，引擎就会使用这个变量，如果否，引擎就会继续查找该变量，直到找到**全局作用域**为止。

> LHS和RHS的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=”赋值操作符的左侧或右侧。

练习1：

```js
function foo (a){ // 这里实际进行的是LHS操作，a = 2
  console.log(a)  // 这里进行的是 RHS操作，寻找当前作用域有没有a这个变量，没有就往外层找
}
foo(2) // 这里先RHS询问作用域有没有foo变量，并且该变量存储的是否是函数
```

练习2:

```js
function foo (a){
  var b = a
  return a + b
}
var c = foo(2)
```

结果如下：

- R：代表RHS查询
- L：代表LHS查询

![image-20221015120632913](/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%8A%E5%8D%B71.1.jpg)

#### 1.3 作用域嵌套

当一个块或函数嵌套在另外一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

#### 1.4 异常

当引擎执行**LHS**查询时，如果在顶层（全局作用域）中无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返回给引擎，前提是程序运行在非严格模式下。

> 注意：严格模式会禁止自动或隐式创建全局变量

ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

### 词法作用域

作用域共有两种工作模型。

- 第一种是最为普遍的，被大多数编程语言所采用的**词法作用域**，
- 第二种是叫做**动态作用域**。仍有一些编程语言在使用（比如Bash脚本、Perl中的一些模式）。

#### 2.1 词法阶段

词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域说由我们在写代码时将变量和块级作用域卸载哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

- ##### 查找

作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。

作用域查找会在找到的第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫做**遮蔽效应**。

> 全局变量会自动成为全局对象的属性（如：浏览器环境下的全局对象window），因此不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用对其进行访问。

```js
window.a
```

通过这种技术可以访问那些被同名变量所掩盖的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法访问到。

无论函数在哪里被调用、也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

#### 2.2 欺骗词法

**欺骗词法作用域会导致性能下降。**

经过下面分析，会给出原因。

##### 2.2.1 eval

JavaScript中eval(...)函数可以接受一个字符串为参数，并将其中内容视为好像在书写时就存在程序中这个位置的代码一样。换句话说，可以在你写代码中用程序生成代码并运行，就好像代码是写在那个位置一样。

例如：

```js
function foo(str,a){
  eval(str)
  console.log(a,b)
}
var b =2;
foo('var b = 3;',1)  // 1 3
```

eval(...)调用中的“var b = 3;”，这段代码会被当作本来就在哪里一样来处理。

> eval(...)通常被用来执行动态创建的代码，因为像例子中这样动态地执行一段固定字符串组成的代码，并没有比直接将代码就写在那里更有好处。

默认情况下，如果eval(...)中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对eval(...)所处的词法作用域进行修改。技术上，通过一些技巧可以间接调用eval来使其运行在全局作用域上，并对全局作用域进行修改。无论何种情况，eval都可以在**运行时**修改书写期的词法作用域。

> 在严格模式下，eval在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

```js
function foo(str){
  'use strict';
   eval(str);
   console.log(a) // ReferenceError: a is not defined.
}
foo('var a = 2')
```

与eval功能很相似的还有：

- setTimeout
- setInterval

它们的第一个参数可以是**字符串**，字符串的内容可以被解释成一段**动态生成**的**函数**代码。

new Function函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数。这种构建函数的语法比eval要安全一些，但也是**不推荐使用**的。

> 在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。

##### 2.2.2 with

JavaScript中另外一个难以掌握（并且也不推荐使用）用来欺骗词法作用域的功能是**with**关键字。

作用：

```js
var obj = {
  a:1,
  b:2,
  c:3
}
// 一系列赋值操作
obj.a = 3
obj.b = 4
obj.c = 6
// 等同于以下
with(obj){
  a = 3
  b = 4
  c = 6
}
```

注意：

```js
function foo (obj){
  with(obj){
    a = 2
  }
}
var obj1 = {
  a:1
}
var obj2 = {
  b:2
}
foo(obj1)
console.log(obj1.a) // 2

foo(obj2)
console.log(obj2.a) // undefined
console.log(a) // 2 a 被泄漏到全局作用域上了！
```

当我们将obj1传递进去，a = 2 赋值操作找到了obj1.a并将2组赋值给它，这也在后面的console.log(obj1.1)中可以体现。而当obj2传递进去，obj2并没有a这个属性，因此不会创建这个属性，故obj2.a是undefined。

> 注意：这里有一个奇怪的副作用，实际上a = 2赋值操作创建了一个全局变量a。

为什么呢？

with可以将一个没有或多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。

eval和with的对比：

- eval：如果接受了含有一个或多个声明的代码，就会修改其**所处**的**词法作用域**。
- with：声明实际上是根据你传递给它的对象凭空创建一个**全新的词法作用域**。 

> 注意：另外一个不推荐使用eval和with的原因是会被严格模式所影响（限制）。with被完全禁止，而保留核心功能的前提下，间接或非安全地使用eval也被禁止了。

##### 2.2.3 性能

eval和with会在**运行时**修改或创建全新的词法作用域，以此欺骗嵌套在书写时定义的词法作用域。而JavaScript是在**编译时**对代码做优化。

如果出现了eval或with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做优化。

如果代码中大量使用了eval和with，那么运行起来一定变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会变得非常慢这个事实。

#### 2.3 小结

- 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。
- 编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

### 函数作用域和块级作用域

#### 3.1 函数中作用域

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案非常有用，能充分利用JavaScript变量可以根据需要改变值类型的**动态**特性。

但与此同时，如果不细心处理那些可以在整个作用域范围内被访问的变量。可能会带来意想不到的问题。

#### 3.2 隐藏内部实现

为什么**隐藏**变量和函数是一个有用的技术？

如果所有变量和函数都在全局作用域中，当然可以在所有的内容嵌套作用域中访问到它们。但这样会破坏前面提到的**最小特权原则**，因为可能会暴露过多的变量和函数，而这些变量或函数本应该是**私有的**，正确的代码应该是可以阻止对这些变量或函数进行访问的。

###### 规避冲突

**隐藏**作用域中的变量和函数所带来的另外一个好处，是可以**避免同名标识符之间的冲突**，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成**命名冲突**。冲突会导致变量的值被意外**覆盖**。

1. 全局命名空间

变量冲突时一个典型例子存在与全局作用域中。当程序加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量**隐藏**起来，就会很容易产生冲突。

这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象呗用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的语法作用域中。

例如：

```js
const MyReally = {
  author: 'yxz',
  doSomething(){
    ...
  }
}
```

#### 3.3 函数作用域

在任意代码片段外部添加包装函数。可以将内部的变量和函数定义**隐藏**起来，外部作用域无法访问包装函数内部的任何内容。

包装函数的声明以(function...而不是function...开始。函数会被当作**函数表达式**而不是一个标准的函数声明来处理。

> 区分函数声明和表达式最简单的方法是看function关键字出现在声明中的位置。如果是(function...)()或(function(){}())就是函数表达式，否则就是一个函数声明。

##### 3.3.1 匿名和具名

```js
setTimeout(function (){
  // 匿名函数表达式
})
```

匿名函数的缺点：

- 匿名函数在栈追踪中不会显示出有意义的函数名，使得难以调试。
- 如果没有函数名，当函数需要引用自身时只能使用**已经过期**的**argument.callee**引用自身，比如**递归**中。另外函数需要引用自身的例子，就是事件触发后事件侦听器需要解绑自身。
- 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称往往可以不言自明。

行内函数表达式非常强大且有用—匿名和具名之间的区别没有本质上的区别。给函数表达式指定一个函数名可以有效解决以上问题。**始终给函数表达式命名是一个最佳实践**。

##### 3.3.2 立即执行函数表达式

- 第一种写法：

```
(function(){
 // ...
})() // 这里的()作为函数调用
```

- 第二种写法：

```js
(function(){
  // ...
}())
```

#### 3.4 块作用域

变量的声明应该距离使用的地方越近越好，并最大限度地本地化。

> 注意：当使用var声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。 -- 变量提升

块级作用域是一个用来对之前的**最小授权原则**进行扩展的工具，将代码从在函数中隐藏信息扩展为块中隐藏信息。

##### 3.4.1 with

...

##### 3.4.2 try/catch

**try/catch**的**catch**分句会创建一个块级作用域，其中声明的变量仅仅在catch内部有效。

##### 3.4.3 let

ES6新增声明变量的语法，这里就不展开说了，直接说细节。

思考：

```js
for(var i=0;i<6;i++){
  setTimeout(()=>{
    console.log(i) // 6个6
  },1000)
}
```

这里为什么会输出6个6，因为**setTimeout**是异步的，打印的时候，循环已经循环完毕了！所以这里会输出6个6

有什么方法可以让它正常输出 0、1、2、3、4、5呢？

- 方法一：

```js
for(var i=0;i<6;i++){
  setTimeout((i)=>{
    console.log(i) // 0 1 2 3 4 5
  },1000,i)
}
```

这里其实是利用了setTimeout函数的第三个参数，每次for迭代的时候都给setTimeout传递一个当前的i的值。

- 方式二：

```js
for(let i=0;i<6;i++){
  setTimeout(()=>{
    console.log(i) // 0 1 2 3 4 5
  },1000)
}
```

这里就是利用到**let**，for循环头部的let将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的**每一个**迭代中，确保使用上一个循环迭代结束时的值重新进行**赋值**。

##### 3.4.3 const

也是ES6新增的，用来声明常量的。

...
### 提升

#### 4.1 先有鸡还是先有蛋

直觉上会认为JavaScript代码在执行时说**由上往下**执行的，但实际上这并不完全正确，有一种特殊情况会导致这一假设上错误的。

例如：

```js
a = 2;
var a;
console.log(a) // 2
```

例如：

```js
console.log(a) // undefined
var a = 2;

等效于以下
var a;
console.log(a)
a = 2;
```

#### 4.2 编译器再度袭来

这里JavaScript实际上会将其看成两个声明：var a； a = 2；

- 第一个定义声明是在**编译阶段**进行的。
- 第二个赋值声明会留在原地等待**执行阶段**。

> 注意：只有声明本身会被提升，而赋值或其他运行会留在原地。并且每个作用域都会进行提升操作。

> 注意：函数声明会被提升，但是函数表达式不会被提升。

#### 4.3 函数优先

函数声明和变量都会被提升。但是一个值得注意的细节，变量和函数，是**函数优先被提升**，然后才是变量。

以下代码验证这一点：

```js
foo() // 1
function foo(){
  console.log(1)
}

foo = function (){
  console.log(2)
}
```

这里输出的是1，而不是2。上面代码实际会转化成以下代码：

```js
function foo(){
  console.log(1)
}

foo() // 1

foo = function (){
  console.log(2)
}
```

> 注意：函数声明会被提升到普通变量之前。

尽管重复的var 声明会被忽视掉，但出现在后面的函数声明还是可以覆盖前面的，如下例子验证这一点：

```js
foo() // 3
function foo(){
  console.log(1)
}
var foo = function (){
  console.log(2)
}
function foo(){
  console.log(3)
}
```

一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示的那样可以被条件判断所控制：

```js
foo() // TypeError: foo is not a function
var a = true;
if(a){
  function foo(){
    console.log(1)
  }
}else{
    function foo(){
    console.log(2)
  }
}
```

但是需要注意这个行为并不可靠，在JavaScript未来的版本中有可能发生改变，因此应该尽可能避免在块内部声明函数。

#### 4.4 小结

- var a =2；看作一个声明，而实际上JavaScript并不那么认为。它首先会将var a和a = 2当作两个独立的声明，第一个是**编译阶段**的任务，而第二个则是**执行阶段**的任务。
- 无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被**移动**到各自作用域的最顶端，这个过程被称为**提升**。
- **函数表达式**的赋值在内的赋值操作并不会提升。

### 作用域和闭包

#### 5.1 启示

闭包上基于**词法作用域**书写代码时所产生的**自然结果**，我们甚至不需要未来利用它而有意识地创建闭包。闭包的创建和使用在我们的代码中随处可见。我们缺少的是根据自己的意愿来识别、拥抱和影响闭包的思维环境。

#### 5.2 实质问题

当**函数**可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在**当前词法作用域之外**执行。

下面来展示一下产生闭包的例子：

```js
function foo(){
  const a = 2;
  function bar(){
    console.log(a)
  }
  return bar
}
const baz = foo()
baz() // 2 这个就是闭包。
```

函数bar()的词法作用域能够访问foo()的内部作用域。在foo函数执行后，通过会期待foo函数的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收机制用来释放不再使用的内存空间。由于看上去foo的内容不会再使用了，所以自然地会考虑对其进行回收。

而**闭包**的神奇之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收掉。谁在使用这个内部作用域？是foo函数本身在使用。

拜bar所声明的位置所赐，它拥有覆盖foo内部作用域的闭包，使得该作用域能够一直存活，以供bar在之后任何时间进行引用。

bar依然持有对该作用域的访问，而这个引用就叫做闭包。

- 闭包使得函数可以继续访问定义时的词法作用域。
- 无论使用何种方式对函数类型的值进行**传递**，当函数在别处被调用时可以被观察到闭包。

以下也是一个闭包：

```js
function foo(){
  let a = 2;
  function baz(){
    console.log(a)
  }
  bar(baz)
}

function bar(fn){
  fn() // 这就是闭包
}

foo()
```

#### 5.3 现在我懂了

- 本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。
- 在定时器、事件监听器、Ajax请求、跨窗口通信、Web Worker或者任何其他异步（或者同步）任务中，**只要使用了回调函数，实际上就是在使用闭包**。

> 通常认为立即执行函数（IIFE）是典型的闭包例子，但是根据前面对闭包的含义，并不同意这个观点，但是IIFE确实是存在了闭包。

#### 5.4 循环和闭包

要说明闭包，for循环说一个典型的例子。

```js
for(var i=1;i<=5;i++){
  setTimeout(()=>{
    console.log(i) // 5个6
  },i*1000)
}
```

正常情况下，这段代码我们预期是每秒一次、每次一个输出1、2、3、4、5。

但实际上，以每秒一次的输出5个6。

延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是**setTimeout**所有的回调函数以恶案是在**循环结束**后才会被执行的。

缺陷是我们试图假设循环中的每个迭代在运行时都会给自己**捕获**一个i的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各自迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i，所以实际上所有函数都共享了一个i的引用。

利用立即执行函数（IIFE）

```js
for(var i=1;i<=5;i++){
(
function (i){
    setTimeout(()=>{
    console.log(i) // 1 2 3 4 5
  },i*1000)
}
)(i)
}
```

每个延迟函数都将**IIFE**在每次迭代中创建的作用域封闭起来。

###### 重返块作用域

let声明，可以用来**劫持**块作用域，并且在这个块作用域中声明一个变量。

> for循环头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。

#### 5.5 模块

最常见的实现模块模式的方法通常被称为**模块暴露**，这里展示的是其变体。

```js
function myMoudle(){
  let auther = [1,2,3];
  function doSomething(){
    console.log(auther,'!!!')
  }
  return {
    auther,
    doSomething
  }
}
const foo = myMoudle()
console.log( foo.auther ) // [1,2,3]
foo.doSomething() //  [1,2,3] !!!
```

> jQuery和$标识符就是jQuery模块的公共API，但是它们本身都是函数（由于函数也是对象，它们本身也可以拥有属性）

模块模式需要具备两个必要条件：

1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包， 并且可以访问或者修改私有的状态。

**一个具有函数属性的对象本身并不是真正的模块**。从方便观察的角度看，**一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块**。

当只需要一个实例时，可以对这个模式进行简单的改进为**单例模式**。

```js
const foo = (
  function MyMoudle(){
    let something = 'cool';
    function doSomething(){
      console.log( something + '!!!' )
    }
    return {
      something,
      doSomething
    }
  }
)()

console.log(foo.something) // cool
foo.doSomething // cool!!!
```

我们将模块函数转换为IIFE，立即调用函数并将返回值直接复制给单例的模块实例标识符foo。

##### 5.5.1 现代的模块机制

大多数模块依赖加载器/管理器本质上都是将这种模式定义封装进一个友好的API。

##### 5.5.2 未来的模块机制

**ES6**中为模块增加了一级语法支持。

> 相比之下，ES6模块API是静态的(API不会在运行时改变)。由于编辑器知道这一点，因此可以在**编译期**检查对导入模块的API成员的引用是否真实存在。如果API引用并不存在，编译器会在编译时就抛出早期错误，而不会等待在**运行期**再动态解析(并报错)。

#### 5.6 小结

**当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。**

模块的两个主要特征：

- 为创建内部作用域而调用了一个包装函数；
- 包装函数的返回值必须至少包含一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包；

### 关于this

#### 1.1 为什么要用this

this提供了一种更优雅的方式来**隐式传递**一个对象引用，因此可以将API设计得更加简洁并且易于复用。

随着我们的使用模式越来越复杂，显示传递上下文对象会让代码变得越来越混乱，使用**this**则不会这样。

> argument.callee来引用当前正在运行的函数对象。这是唯一一种可以从匿名函数对象内部引用自身的方法。然而，更好的方法是避免使用匿名函数，至少在需要自引用时使用具名函数（函数表达式）。argmuent.callee已经**被弃用**，不应该再使用它。

以下代码，我们想要记录foo被调用的次数:

```js
function foo(num){
  console.log('foo:',num)
  this.count++
}

foo.count =0

for(let i=0;i<10;i++){
  if(i>5){
    foo(i)
  }
}

// foo:6
// foo:7
// foo:8
// foo:9
console.log(foo.count) // 0
```

为什么foo.count还是0？这里foo函数也确实执行了四次，并打印了四次log，由此可以推断出函数是执行了，但是this.count并没有++，其实count++了，但是此时的this是指向全局作用域对象的(window)，所以循环走完后，winodw下就可以访问到count变量，但很遗憾这里的值是**NaN**，因为刚开始window下访问count还是undefined，undefined++自然就是NaN了。

那么我们这里可以怎么巧妙的利用灵活的this机制去解决这个问题呢？

```js
function foo(num){
  console.log('foo:',num)
  this.count++
}

foo.count =0

for(let i=0;i<10;i++){
  if(i>5){
    foo.call(foo,i)
  }
}

// foo:6
// foo:7
// foo:8
// foo:9
console.log(foo.count) // 4
```

这里利用call改变了foo的this指向。

#### 1.2 它的作用域

- this在任何情况下都不指向函数的词法作用域。
- 在JavaScript内部，作用域和对象类似，可见的标识符都是它的属性。但是**作用域对象**无法通过JavaScript代码访问，它存在于JavaScript引擎内部。
- 每当你想要把this和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。

#### 1.3  this到底是什么

1. this是在**运行时**进行绑定的，并不是在编写时绑定的，它的上下文取决于**函数调用时**的各种条件。
2. this的绑定和**函数声明的位置**没有任何关系，只取决于函数调用方式。
3. 当一个函数被调用时，就会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含**函数在哪里被调用(调用栈)**、**函数的调用方式**、**传入的参数**等信息。this就是这个记录的属性，会在**函数执行**的过程中用到。

### this全面解析

#### 2.1 调用位置

**调用位置就是函数在代码中被调用的位置，而不是声明的位置。**

通常来说，寻找调用位置就是寻找**函数被调用的位置**，但是做起来并没有这么简单，因为某些编程模式可能会**隐藏**真正的调用位置。

最重要的是分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的是调用位置就在当前正在执行的函数的**前一个**调用中。

下面来看看什么是调用栈和调用位置：

```js
function baz(){
  // 当前调用栈是：baz
  // 因此，当前调用位置是全局作用域
  console.log('baz')
  bar() // bar的调用位置
}

function bar(){
  // 当前调用栈是：baz-->bar
  // 当前调用位置是在bar上
  console.log('bar')
  foo() // foo的调用位置
}

function foo(){
  
   console.log('foo')
}

baz() // baz的调用位置
```

> 你可以把调用栈想像成一个函数调用链。

#### 2.2 绑定规则

##### 2.2.1 默认绑定

```js
function foo(){
  console.log(this.a)
}

var a = 2
foo()  // 2
```

声明全局作用域中的变量(比如var a = 2)，就是全局对象(window)下的一个**同名属性**。它们本质是同一东西，并不是通过复制得到的，就像一个硬币的两面一样。

> 注意：严格模式下(strict mode)下，则不能将全局对象用于**默认绑定**，因此this是undefined。

##### 2.2.2 隐式绑定

思考一下以下代码：

```js
function foo(){
  console.log(this.a)
}
const obj ={
  a:2,
  foo:foo
}

obj.foo() // 2
```

首先需要注意的是foo()的声明方式，及其之后是如何被当作引用属性添加到obj中的。但是**无论是直接在obj中定义还是先定义再添加引用属性。这个函数严格来说都不属于obj对象的。**

然而，调用位置会使用obj上下文来引用函数，因此你可以说函数被调用时obj对象**拥有**或者**包含**函数引用。

**对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。**

```js
function foo(){
  console.log(this.a)
}

const obj1 = {
  a:42,
  foo:foo
}

const obj2 = {
  a:2,
  obj1:obj1
}

obj2.obj1.foo() // 42
```

###### 隐式丢失

一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是上它会作用应用默认绑定，从而把this绑定到全局对象或者undefined中，取决于是否上严格模式。

参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。

调用回调函数的函数可能会修改this。在一些流行JavaScript库中事件处理器常会把回调函数的this强制绑定到触发事件的DOM元素上。

##### 2.2.3 显式绑定

JavaScript提供的绝大多数函数以及我们自己创建的所有函数都可以使用call(...)、apply(...)方法。

它们的第一个参数是一个对象，是给this准备的，接着在调用函数时将其绑定到this。因为你可以直接指定this到绑定对象，因此我们称之为**显式绑定**。

**如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作this到绑定对象，这个原始值会被转换成它的对象形式（也就是new String(...))、new Boolean(...)，通常被称为“装箱”。--包装类型**

##### 2.2.4 new绑定

在JavaScript中，构造函数只是一些使用new操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，**它们只是被new操作符调用的普通函数而已**。

实际上不存在所谓的**构造函数**，只有对于函数的**构造调用**。

使用new来调用函数，或者说发生构造函数调用时，会做那些事：

1. 创建（或者说构造）一个全新的对象。
2. 这个对象会执行[[prototype]]连接。 （将属性和方法添加到这个新对象里）
3. 这个新对象会绑定到函数调用的this。
4. **如果函数没有返回其他对象，那么new表达式中的函数调用就会自动返回这个新对象。**

new说最后一种可以影响函数调用时this绑定行为的方法，我们称之为**new绑定**。

#### 2.3 优先级

**显性绑定 > new绑定 > 隐式绑定**

Function.prototype.bind(...)会创建一个新的包装函数，这个函数会忽略它当前的this绑定（无论绑定的对象是什么），并把我们提供的对象绑定到this上。

手写一个简易版本的bind:

```js
Function.prototype.bind = function(oThis){
  if(typeof this !=='function'){
    throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable')
  }
  let aArgs = Array.prototype.slice.call(argument,1),
      fToBind =this,
      fNOP = function (){
        return fToBind.apply(
       ( this instanceof fNOP &&
        oThis ? this : oThis),
          aArgs.concat(
          Array.prototype.slice.call(arguments)
          )
        )
      }
  fNOP.prototype = this.prototype
  fBound.prototype = new fNOP()
  return fBound
}
```

我们重点放到这一段代码上：

```js
this instanceof fNOP &&
oThis ? this : oThis
// 以及
fNOP.prototype = this.prototype
fBound.prototype = new fNOP()
```

这段代码会判断硬绑定函数是否是被new调用，如果是的话就会使用新创建的this替换掉硬绑定的this。

之所以要在new中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其他参数。bind( ... ) 的功能之一就是**可以把除了第一个参数（第一个参数用于绑定this）之外的其他参数都传给下层的函数（这种技术称为"部分应用"，是柯里化的一种）**。

```js
function foo(p1,p2){
 this.val = p1 + p2
}

const bar = foo.bind('p1')
const baz = new bar('p2')
baz.val  // p1p2
```

###### 判断this

1. 函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。

```js
const bar = new foo()
```

2. 函数是否在call、apply（显式绑定）或者硬绑定调用？如果是的话，this绑定的是指定的对象。

```js
const bar = foo.call(obj)
```

3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。

```js
const bar = obj1.foo()
```

4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定在undefined，否则绑定到全局对象。

```js
const bat = foo()
```

#### 2.4 绑定例外

##### 2.4.1 被忽略的this

**如果你把null或者undefined作为this的绑定对象传给call、apply或者bind，这些值会被调用时被忽略，实际应用的是默认绑定规则。**

```js
function foo(){
  console.log( this.a )
}
let a = 2
foo.call(null) // 2
```

什么情况会传入null？

1. 使用apply来**展开**数组。（在ES6之前，ES6之后可以使用`...`展开运算符）
2. 使用bind可以对参数进行柯里化。（预先设置一些参数）

```js
function foo(){
  console.log('a:'+ a + 'b:' + b)
}
const bar = foo.call(null,1)
bar(2)  // a:1 b:2
```

> 在ES6之前没有柯里化的相关语法，因此还需要使用bind( ... )。

然而，总是使用null来忽略this绑定可能会产生一些副作用。如果某个函数确实使用了this（比如第三方库中的一个函数），那默认绑定规则会把this绑定到全局对象，这将导致不可预计的后果（比如修改全局对象）。

##### 更安全的this

一种更安全的做法是传入一个特殊的对象。在JavaScript中创建一个空对象最简单的方法都是**Object.create(null)**和**{}**很像，但是**Object.create并不会创建Object.prototype委托**，所以它比{}更空。

##### 2.4.2 间接引用

间接引用最容易在赋值时发生：

```js
function foo(){
  console.log( this.a )
}
let a = 2
let obj = {
  a:3,
  foo:foo
}
let p = {
  a:99
}
obj.foo() // 3
(p.foo = obj.foo)() // 99
```

赋值表达式p.foo = obj.foo的返回值是目标函数的引用，因此调用位置是foo()而不是p.foo()或者obj.foo()。

> 注意：对于默认绑定来说，决定this绑定对象的并不是**调用位置**是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this会被绑定到undefined，否则this绑定到全局对象。

##### 2.4.3 软绑定。

硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显示绑定来修改this。

#### 2.5 this词法

箭头函数不使用this到四种标准规则，而是根据外层（函数或全局）作用域来决定this。箭头函数可以像bind(...)一样确保函数的this被定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的this机制。

```js
function foo(){
  // ES6之前通常是使用这种方式来保存this
  const _this = this
  setTimeout(function (){
    console.log(_this.a)
  })
}
const obj = {
  a:2
}
foo.call(obj) // 2
```

虽然_this = this和箭头函数看起来都可以取代bind(...)，但是从本质上来说，它们像替代的是this机制。

如果经常编写this风格的代码，但是绝大多数的时候都会使用_this = this 或者箭头函数来否定this机制，那我们应当：

1. 只使用此法作用域并完全抛弃错误this风格的代码。
2. 完全采用this风格，在必要时使用bind(...)，尽量避免使用_this=this和箭头函数。

#### 2.6 小结

如果要判断一个运行中的函数的this绑定，就需要找到这个函数的**直接调用位置**。

四条规则判断this绑定对象：

- 由new调用：绑定到新创建的对象。
- 由call或者apply调用：绑定到指定对象。
- 由上下文对象调用：绑定到那个上下文对象。
- 默认：在严格模式下，绑定到undefined上，否则绑定到全局对象。

> 有些调用可能在无意中使用了默认绑定规则，如果想“更安全”地忽略this绑定，你可以使用一个DMZ对象，比如a=Object.create(null)，以保护全局对象。

箭头函数会继承**外层函数调用**的this绑定（无论this绑定到什么）。这其实和ES6之前代码的**_this = this**机制一样。

### 对象

#### 3.1 语法

对象可以通过两种形式定义，声明(文字)形式(字面量声明)和构造形式。

对象的文字语法：

```js
const obj = {
  key:value
}
```

构造形式：

```js
const obj = new Object()
obj.key = value 
```

构造形式和文字形式生成的对象是一样。唯一的区别就是，在文字声明中你可以添加多个键值对，但是在构造形式呢必须逐个逐个添加属性。

#### 3.2 类型

在JavaScript中一共有**八种**数据类型。（包含ES6）

- string
- number
- boolean
- null
- undefined
- bigInt
- Symbol

> 注意：null有时候会被当作一种对象类型，但是这其实只是语言本身的一个bug，既对null执行**typeof null**会返回字符串object。实际上，**null本身是基本类型**。
>
> 原理：不同的对象在底层都表示为二进制，在JavaScript中二进制前三位都为0的话会被判断为object，null的二进制表示全是0，自然前三位也是0，所以会被判断为object类型。

```js
let str = 'I am Xianzhu-Yang'
tyoeof str ==> string
str instanceof String. // false

let strObject = new String('I am stringObj')
typeof strObject ==> object
strObject instanceof String. // true
```

原始值"I am Xianzhu-Yang"并不是一个对象，它只是一个字面量，并且是一个不可边的值，如果要在这个字面量上执行一些操作，比如**获取长度**、**访问其中**某个字符串等，那需要将其转换为String对象。

幸运的是，在必要时语言会自动把字符串字面量转换成一个string对象，也就是说你并不需要显式创建对象。**引擎会自动把字面量转换为String对象，所以可以访问属性和方法。**

null和undefined没有对应的构造形式，它们只有字面形式。相反，Date只有构造形式，没有文字形式。

对于Object、Array、Function和RegExp（正则）来说，无论使用文字或构造形式，它们都是对象，不是字面量。在某些情况下， 相比用文字形式创建对象，构造形式可以提供一些额外选项。由于这两种形式都可以创建对象，所以我们首选更简单的文字形式。建议只在需要哪些额外选项时才使用构造形式。

Error对象很少在代码中显示创建，一般是在抛出异常时被自动创建。也可以使用new Error(...)这种构造形式来创建，不过一般用不着。

#### 3.3 内容

对象内容是由一些存储在特定命名为主的（任意类型的）值组成的，我们称之为属性。

**存储在对象容器内部的是这些属性的名称，它们都被称为指针（从技术角度来说是引用）一样，指向这些值真正的存储位置。**

访问对象属性可以分为两种方式：属性访问、键访问。

这两种语法的主要区别：

- 操作符要求属性名必须满足标识符的命名规范。
- 键访问语法可以接受任意UTF-8Unicode字符串作为属性名。举例来说，如果要引用名称为了**xian-zhu**这个属性名，就必须使用键访问。

在对象中，**属性名永远都是字符串**。如果你使用string字面量以为的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组中下标使用的的确是数字，但是在对象属性名中会转换为字符串。

##### 3.3.1 属性和方法

确实，有些函数具有this引用，有时候这些this确实会指向调用位置的对象引用。但是这种用法从本质上来说并没有把一个函数变成一个方法，因为this上在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说上间接关系。

##### 3.3.2 数组

数组和对象都是根据其对应的行为和用途进行优化的，所以最好只用对象来存储**键值对**，用数组存储数值下标。

#### 3.3.3 复制对象

思考一下这个对象：

```js
function anotherFunction(){}
const anotherObject = {
  a:true
}

cosnt anotherArray = []

const myObject = {
  a:2,
  b:anotherObject,
  c:anotherArray,
  d:anotherFunction
}

anotherArray.push(anotherObject,myObject)
```

如何准确的表示myObject的复制。

对于浅拷贝来说，复制出的是新对象中a的值会是旧对象a的值，也就是2，简单类型就是值的传递。但是新对象中的b、c、d三个属性其实只是三个引用，它们和旧对象引用是一样的。对于深拷贝来说，除了复制myObject以外还会复制anotherArray。这时问题就来了，anotherArray引用了antherObject和myObject，所以又需要复制myObject，这样就会由于**循环引用**导致死循环。

##### 3.3.3 复制对象

思考一下这个对象：

```js
function anotherFunction(){}
const anotherObject = {
  a:true
}

cosnt anotherArray = []

const myObject = {
  a:2,
  b:anotherObject,
  c:anotherArray,
  d:anotherFunction
}

anotherArray.push(anotherObject,myObject)
```

如何准确的表示myObject的复制。

对于浅拷贝来说，复制出的是新对象中a的值会是旧对象a的值，也就是2，简单类型就是值的传递。但是新对象中的b、c、d三个属性其实只是三个引用，它们和旧对象引用是一样的。对于深拷贝来说，除了复制myObject以外还会复制anotherArray。这时问题就来了，anotherArray引用了antherObject和myObject，所以又需要复制myObject，这样就会由于**循环引用**导致死循环。

有些人通过toString()来序列化一个函数的源代码(但是结果取决于JavaScript引擎的具体实现，而且不同的引擎对于不同类型的函数处理方式不完全相同)。

```js
// 深拷贝的一种方式
const newObj = JSON.parse(JSON.stringify(target))
```

> 注意：JSON实现深拷贝，如果要拷贝的目标对象里有Date时间对象会把时间对象转换成字符串，如果有函数会被遗漏掉，如果是undefined的值也会被忽略掉。

相比深拷贝，浅拷贝的问题就少得多了，在ES6定了Object.assing(目标对象，要拷贝的对象，要拷贝的对象)，它会遍历一个或多个源对象（要拷贝的对象）的所有**可枚举**的**自有键**，并把它们复制（使用=操作符赋值）到目标对象，最后返回目标对象。

> 由于Object.assgin(...)就是使用=操作符来赋值，所以以源对象属性的一些特性（比如writable）不会被复制到目标对象。

##### 3.3.5 属性描述符

从ES5开始，所有的属性都具备了**属性描述符**。

1. writable

writable决定是否可以修改属性的值。

```js
const obj ={}
Object.defineProperty(obj,'a',{
  value:2,
  writalbe:falas, // 不可修改
  configurable:true, // 是否可配置
  enumerable:true. // 是否可枚举
})
obj.a = 3
console.log(obj.a) // 2
```

对于设置了writable的属性，修改它会**静默失败**，如果在严格模式下会报错。

2. configurable

只要属性是可配置的，就可以使用defineProperty(...)方法来修改属性描述符。

> 不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错。即便属性是configurable:false，我们还是可以把writable的状态由true改为false，但是无法从false改成true。除了无法修改，configurable:false还会禁止删除这个属性。

delte只用来直接删除对下那个的(可删除)属性。如果对象的某个属性是某个对象/函数的最后引用者，对这个属性执行delete操作之后，这个未引用的对象/函数就可以被垃圾回收了。但是，不要把delte看作一个释放内存的工具(就像C/C++中)，它就是一个删除对象属性的操作，仅此而已。

3. enumerable

这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说**for...in**循环。如果把enumerable设置为false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对的，设置成true就会让它出现在枚举中。

3.3.6 不变性

所有的方法创建的是浅不变性，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象(数组/对象/函数等)，其他对象的内容不受影响，仍然是可变的。

> 在JavaScript程序中很少需要深不变性。有些特殊情况可能需要这样做，但是根据通用的设计模式，如果你发现需要密封或者冻结所有对象，那我们或许应当退一步，思考一下程序的设计，让它能更好地应对对对象值的改变。

1. 对象常量

```js
const myObj = {}
Object.defineProperty(myObj,'name',{
  value:'yxz',
  writable:false,
  configurable:false
})
```

2. 禁止扩展

如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(...)

```js
const myObject ={
  a:2
}
Object.preventExtensions(myObject)
myObject.a = 9
console.log(myObject.a) // 2
```

非严格模式下，会静默失败，否则会报错。

3. 密封

Object.seal(...)会创建一个"密封"的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(...)并把所有现有的属性标记为configurable:false。

所以密封后的对象不仅不能添加新属性，也不能重新配置或者删除任何现有的属性（虽然可修改它的值）。

4. 冻结

Object.freeze(...)会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(...)并把所有**数据访问**属性标记为writable：false，这样就无法修改它们的值。

你可以深度冻结一个对象，具体方法为：首先在这个对象上调用Object.freeze(...)，然后遍历它引用的对象并把这些对象上调用Object.freeze(...)，但是一定要小心，因为这样做，有可能会冻结到其他需要**共享的对象**。

##### 3.3.7 [[Get]]

```js
const obj ={
  a:1
}
obj.a // 1
```

在语言规范中，obj.a在obj上实际上是实现了[[Get]]操作(有点像函数调用[[Get]])。对象默认的内置[[Get]]操作首先在对象中查找是否有名称相同的属性，如果找到就返回这个属性的值。

如果没有找到名称相同的属性，按照[[Get]]算法的定义会执行例外一种非常重要的行为。其实就是遍历可能存在的[[prototype]]链，也就是**原型链**。

```js
const obj = {
  a:undefined
}
obj.a // undefined
obj.b // undefined
```

从返回值的角度来说，这两个引用没有区别——它们都返回了undefined。然而，尽管咋看之下没有区别，实际上底层的[[Get]]操作对obj.b进行了更复杂的处理。

仅通过返回值，你无法判断一个属性是否存在并且持有一个undefined值，还是变量不存在，所以[[Get]]无法返回某个特定而返回默认的undefined。

##### 3.3.8 [[Put]]

[[Put]]被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性(这是最重要的因素)。

如果已经存在这个属性，[[Put]]算法大致会检查下面这些内容。

1. 属性是否访问描述符？如果是并且存在setter就调用setter。
2. 属性的数据描述符中writable是否是false？如果是，在非严格模式下会静默失败，在严格模式下会抛出TypeError异常。
3. 如果都不是，将该值设置为属性的值。

如果对象中不存在这个属性，[[Put]]操作会更加复杂。

3.3.9 Getter和Setter

对象默认的[[Put]]和[[Get]]操作分别可以控制属性值的设置和获取。

> 在语言的未来/高级特性中，有可能可以改写整个对象(不仅仅是某个属性)的默认[[Get]]和[[Put]]操作。

在ES5中可以使用getter和setter部分改写默认操作，但是只能应用在单个属性上，无法应用到整个对象上。**getter上一个隐藏函数，会在获取属性值时调用。setter也是一个隐藏函数，会在设置属性值时调用。**

##### 3.3.10 存在性

我们可以在不访问属性值时判断对象中是否存在这个属性:

``` js
const obj ={
  a:2
}
('a' in obj)  // true
('b' in obj)  // false
```

in操作符会检查属性是否在对象及其[[prototype]]原型链中。相比之下，hasOwnProperty(...)只会检查属性是否存在obj对象中，不会检查[[prototype]]链。

Object.hasOwnProperty.call(obj,'a')，它借助了基础的hasOwnProperty方法并把它显性绑定到obj上。

> 看起来in操作符可以检查容器内是否有某个值，但是它实际上检查的是某个属性名是否存在。对于数组来说这个区别非常重要，4 in [2,4,6]返回的是false，因为[2,4,6]数组中并没有下标为4的值。

#### 3.4 遍历

for...in可以用来遍历对象的可枚举属性列表(包括prototype链)。

在JavaScript中，给我们内置了一些遍历回调函数，每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它们对于回调函数处理方式不太一样。

- forEach：遍历数组的所有值并忽略回调函数的返回值。
- every：会一直运行直到回调函数返回false（或者其他假值）。
- some：会一直运行直到回调函数返回true（或者其他真值）。

every和some中特殊的返回值会普通的for循环中的break语句类似，它们会提前终止遍历。

> 在遍历数组下标时采用的是数字顺序(for循环或者其他迭代器)，但是遍历对象属性时的顺序是不确定的，在不同的JavaScript引擎中可能是不一样的。

在ES6中新增了一个for...of方法

```js
const arr = [1,2,3]
for(const v of arr){
  console.log(v) // 1 2 3
}
```

for...of语法循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值。

数组有内置的@@iterator，因此for...of可以直接应用在数组上。我们也可以使用内置的@@iterator来手动遍历数组。

```js
const arr = [1,2,3]
const it = arr[Symbol.iterator]

it.next() // {value:1,done:flase}
it.next() // {value:2,done:flase}
it.next() // {value:3,done:flase}
it.next() // {done:true}
```

> 引用类似iterator的特殊属性时要使用符号名 ，而不是符号名包含的值。此外，虽然看起来很像一个对象，但是@@iterator本身并不是一个迭代器对象，而是返回迭代器对象的函数——这一点非常精妙并且非常重要。

和数组不同，普通对象没有内置的@@iterator，所以无法自动完成for...of遍历。之所以要这样做，有许多非常复杂的原因，不过简单来说，这样做是为了避免影响未来的对象类型。

如果想要给任何想遍历对象定义@@iterator：

```js
const obj ={
  a:1,
  b:2
}


Object.defineProperty(obj,Symbol.iterator,{
  enumerable:false,  // 不可枚举
  writable:false,   // 不可修改
  configurable:true, // 可配置
  value:()=>{
    let index = 0
    let ks = Object.keys(this)
    return {
      next:()=>{
        return {
          value:this[ks[index++]],
          done:(index > ks.length)
        }
      }
    }
  }
})

const it =obj[Symbol.iterator]()
it.next() // {value:2,done:false}
it.next() // {value:3,done:false}
it.next() // {done:true}

for...of遍历
for(const k of obj){
  console.log(v)  // 2 3
}
```

for...of循环每次调用obj迭代器对象的next方法时，内部的指针都会向前移动并返回对象属性列表的下一个值。

#### 3.5 小结

- 有时候构造形式创建对象可以提供更多选项。
- 访问属性时，引擎实际上会调用内部默认的[[Get]]操作(在设置属性值时说[[Put]])，[[Get]]操作会检查对象本身是否存在这个属性，如果没有找到还会向[[prototype]]链上去找。
- for...of会寻找内置或者自定义的@@iterator对象并调用它的next(...)方法来遍历数组。

### 混合对象类

面向类的设计模式：实例化、继承、多态。

#### 类理论

类/继承描述了一种代码的组织结构形式——一种软件中对真实世界中问题领域的建模方法。

面向对象编程强调的是数据和操作数据的行为本质上说互相关联的(当然，不同的数据有不同的行为)，因此好的设计就是把数据以及和它的相关行为打包/封装起来，这在正式的计算机科学中有时被称为**数据结构**。

类的另外一个核心概念是多态，这个概念是说父类的通用行为可以被子类用更特殊的**行为重写**。实际上，相对多态允许我们从重写行为引用基础行为。

类理论强烈建议父类和子类使用相同的方法名来表示特定的行为。从而让子类重写父类的行为。

## 你不知道的JavaScript系列-中卷

## 你不知道的JavaScript系列-下卷

## JavaScript设计模式

## 学习JavaScript数据结构与算法