---
title: 面试记录
description: 面试记录
layout: ../../../layouts/MainLayout.astro
---

### 珠海格力
#### 箭头函数和普通函数的区别

- 箭头函数没有自己的this指向，它的this指向上下文的，而普通函数this指向最后调用它的那个调用者。
- 箭头函数没有`arguments`，因为它没有`prototype`属性。
- 箭头函数更简洁，ES6后出的。
- 箭头函数的形参当只有一个的时候，可以省略小括号，如果执行体只有一条语句可以去掉大括号，并且可以省略`return`关键字

#### 数组去重的方法

- for、while循环
- ES6的`new Set`方法

#### 组件通信传递方式

- 父子通信 `props`、`emit`、`ref`
- vuex、eventBus
- 跨级组件 `provide`提供者、`inject`消费者

#### vue2的响应式原理是什么

vue2响应式原理使用到了ES6的`Object.defineProperty`来对数据的劫持，进而实现数据的双向绑定。

当我们定义在data里面的数据，vue底层帮我们使用到了defineProperty来给数据绑定`get`和`set`，但读取属性时，会触发get这个方法，当修改属性时，会触发set这个方法，对于一些深层次的结构对象，需要使用递归来遍历每个属性，所以初始化是比较损失性能的。这个方法是不能够侦听到数据的变化的，但是可以使用到vue给我们重写了那七个改变原数组的方法来实现修改数据响应页面，push、pop、unshift、shift、sort、reverse、splice方法。同时给对象后添加新的属性和删除属性，是没有响应式的。可以使用vue给我们提供的$set方法。

#### API封装包含哪些方面

比如设置baseUrl基地址、统一的响应超时时间，请求、响应拦截器等。

- 建立api文件。
- 根据不同的接口类型存放不同的js文件里，便于后期查找和阅读。

#### 项目中做过了哪些前端优化

- 路由的懒加载，减少首屏加载时间
- 对于一些小图标，做成精灵图，减少请求次数
- 一些公共样式单独抽离出来，需要引入使用
- 对于一些长列表数据，可以使用表格进行分页，数据一页一页的往服务器里取，减少服务器压力
- api的封装
- 封装骨架屏，减少用户在等待时间的焦虑

#### 怎么判断数据类型？ 引用类型/常用类型

- 引用类型

  - 利用万能检查类型方法`Object.prototype.toString.call(要检测的数据)`

    ```js
    const str = '杨某某'
    console.log(Object.prototype.toString.call(str)) // [object String]
    ```

- 基本类型

  - typeof
    - 判断太多数类型都是准确的，注意`typeof null ==> object`
  - instanceof
    - 判断目标数据是否在谁的`原型链`上，返回一个布尔值。

#### js中有几种数据类型

- undefined
- null
- String
- Number
- Boolean
- Object
- bigInt  `ES6后出`

#### 跨域的问题

跨域，是浏览器出于安全考虑提出同源策略。是仅仅存在于浏览器和服务器之间，协议、端口号、域名有一个不同都违反了浏览器的同源策略。

解决方法：

- jsonp：只支持get请求，不支持post请求
- 反向代理：配置一下即可解决跨域问题，底层是帮我们开启了一个微型服务器，通过这个微型服务器去访问目标服务器取数据，去到数据再返回给浏览器，因为服务器和服务器之间是不存在跨域问题的。
- ifram标+|domain

#### 对vue2的理解

`响应式原理`：vue2是使用`Object.defineProperty`来对数据劫持，实现响应式的。

缺点：

- 初始化数据给数据递归遍历绑定get、set是比较损耗性能的。
- 不能侦听数据的变化，需要使用到vue给我们重写的那七个方法和`$set`来实现数据的响应式
- 对于对象后添加的属性和删除属性是无法检测到的，所以不是响应式的，可以利用`$set`方法
- 对于vue2，vue3使用的`Proxy`代理对象实现数据的响应式的，这个方法实现数据的响应式比起vue2来说，性能来说是比较好的，因为Proxy是对整个对象做代理，不需要递归遍历所有数据绑定get、set，而且能够侦听数组的变化，对于对象后添加的属性也能监听到。

#### vue2和vue3的区别

- 实现响应式原理不一样
- vue3不需要像vue2那样this拿数据
- vue3使用了TS重写了，更好的类型推断，更好的支持TS
- `重要`：vue3也引入了`hooks`函数
- 定义数据方式不一样，vue2是传统的`options`api，而vue3改为了`composition`api，传统的options更好的学习成本，利于初学者学习，但不利用后期维护，composition更好复用代码以及后期维护
- vue3最大的特点，我觉得是引入了hooks，更好的代码复用，也解决了vue2的代码复用mixins的缺点：`数据来源不够明确`，`命名冲突`等问题。hooks的出现正好解决了这个问题。
- 生命周期不一样：vue3移除了`beforeCreate`和`created`钩子，可使用`setup`方法代替vue2的beforeDestroy===>beforeUnMount 、 destroyed  ----  unMounted

#### 项目中平时怎么管理接口

- 利用apipost管理

#### 项目中对于重复请求是如何解决的

利用`repeat-request-minde`这个库检测有没有重复请求接口。

重复请求的危害：

- 增加服务器的压力
- 可能会因为其中的某个请求失败导致页面显示错误

解决思路：

- 前置处理：一般开发的时候可能不会留意到有重复的请求，要避免这种情况需要自动监控并给出警告，才能从源头杜绝重复请求的发生。
- 后置处理：出现了重复请求之后能够自动取最后的请求，不发出之前的请求。
- 先找出重复请求的根源，比如一些按钮，用户短时间多次点击导致的多次请求，这时可以利用按钮的`disabled`属性关闭按钮的点击功能，又或者添加一些loading框，防止用户多次点击，导致重复请求。

#### 服务端渲染-SSR

`hydration` 注水：服务端渲染场景下，首次渲染返回静态字符串，并没有交互能力。这时需要对代码进行注水，使之功能完整。